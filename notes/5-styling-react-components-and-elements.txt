==============================================
Section 5: Styling React Components & Elements
==============================================

------------------------------------
64. Outlining the Problem Set
------------------------------------

Inline Styles:
--
Advantage:
- Styles are scoped to that component.

Disadvantage:
- Cannot utilize all CSS features.
(eg. sudo selectors, media queries)


External CSS Styles:
--
Advantage:
- Able to utilize all CSS features.

Disadvantage:
- Styles are globally set.
(eg. If you style a <button>, it styles all <button> elements)



------------------------------------
65. Setting Styles Dynamically
------------------------------------

We can manipulate inline 'style' properties dynamically with JavaScript:
--


render() {
    const style = {
        backgroundColor = 'green',
        ....
    }

    if (this.state.showPersons) {
        ....
        
        style.backgroundColor = 'red';
    }

    return (
        <div className="App">
            ....
            <button
                style={style}
                onClick={this.togglePersonsHandler}
            >Toggle Persons</button>
        </div>
    );
}
--

In the example above, we initially set the 'backgroundColor' property of our 'style' object to 'green'. This way the button is green when the <Person /> components are hidden.

Then when the 'showPersons' boolean flips to 'true' and we show the <Person /> components, we also change the 'backgroundColor' property of our 'style' object to 'red'. We do this to singal to the user that the next click will hide the <Person /> components.

'style' can still stay a constant, as we are not manipulating the object itself, we are just manipulating the value of a property inside of the object.



------------------------------------
66. Setting Class Names Dynamically
------------------------------------

You can dynamically assign classes to an element as long as what's passed into the 'className' property results in a string:
--
const classes = [];

if (this.state.persons.length <= 2) {
    classes.push('red'); // ['red']
}

if (this.state.persons.length <= 1) {
    classes.push('bold'); // ['red', 'bold']
}

return (
    <p className={classes.join(' ')}>Test Text</p>
);
--

In the example above we create a 'classes' variable which holds a list of relevent classes for our element. 

By using JavaScript, we check for conditions in our application, and adjust the 'classes' list based on that logic.

In-order to display the styles, we append the 'classes' array to the elements 'className' attribute and convert it to a string using the 'join()' method. We add a space when using 'join()' to ensure each item in the list is separated by a space in the string. 
(eg. className={classes.join(' ')})



------------------------------------
67. Adding and Using Radium
------------------------------------

In-order to use sudo selectors and media queries in our inline styles, we can add an npm pakage called 'Radium':
--
npm install --save radium
--

Once the package is installed, you can begin using sudo selectors and media queries in our inline styles by first importing it into the file in-which you'd like to use Radium:
--
import Radium from 'radium';
--

Radium is a higher-order component, so where we export our function, we need to wrap Radium around the name of the exported function:
--
export default Radium(App);
--

The export example above will inject extra functionality into our export.

With all of the above setup, we can now begin using the features Radium provides:
--
const style = {
    backgroundColor: 'green'
    color: 'white'
    ':hover': {
        backgroundColor: 'lightgreen',
        color: 'black'
    }
}

.....

style.backgroundColor: 'red'
style[':hover'] = {
    backgroundColor: 'salmon',
        color: 'black'
}
--

In the above example, we use the ':hover' sudo selector both in our initial 'style' object, and later on when we manipulate those values. 

Radium requires us to wrap the sudo selector in single quotation marks (''). This sudo selector is itself an object {} which we can nest css properties inside of to change our element when 'hover' is in effect.


------------------------------------
68. Using Radium for Media Queries
------------------------------------

If you want to use media queries with Radium, there is an extra step you need to do to make this work.

You need to import the named 'StyleRoot' export from 'radium' into your 'App.js' file, and wrap your application inside of a <StyleRoot>....</StyleRoot> higher-order component:
--
App.Js
--
import Radium, { StyleRoot } from 'radium';

return (
    <StyleRoot>
        <div className="App">
            ....
        </div>
    </StyleRoot>
);
--

-- 
Person.Js
--
import Radium from 'radium';

const style = {
    '@media (min-width: 500px)': {
        width: '450px'
    }
}

<div className="Person" style={style}>
    ....
</div>


export default Radium(person);
--

In the example above, in our 'App.js' file we import 'StyleRoot' from 'radium', Then we wrap our JSX in <StyleRoot>....</StyleRoot>. With that set up, we can then use media queries in our application where we use Radium.

Next in 'Person.js' we use a media query in our 'style' constant, which is applied as an inline style to an element. 

Similar to using sudo selectors, media queries using Radium are also objects {}, which we nest css properties inside of to change our element when the query is in effect.



------------------------------------
70. Enabling & Using CSS Modules
------------------------------------





------------------------------------
71. More on CSS Modules
------------------------------------





------------------------------------
72. Adding Pseudo Selectors
------------------------------------





------------------------------------
73. Working with Media Queries
------------------------------------





------------------------------------
74. Useful Resources & Links
------------------------------------

