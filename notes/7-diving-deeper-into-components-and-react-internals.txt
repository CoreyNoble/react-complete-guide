==========================================================
Section 7: Diving Deeper into Components & React Internals
==========================================================

------------------------------------
85. A Better Project Structure
------------------------------------

In previous examples we organized components in a sub-optimal way. Ideally we should re-organize our file structure to follow a convention, in-order make it easier to navigate through and find files in our application.

The standard approach would look something like:
--
/src/index.js
/src/App.js
/src/assets/....
/src/components/Persons/Persons.js
/src/components/Persons/Person/Person.js
/src/containers/....
/src/hoc/....
/src/hooks/....
/src/shared/....
/src/store/actions/....
/src/store/reducers/....
/src/store/sagas/....
--

The primary files in the application (App, index, ...) should be in the root of the /src/ folder.

Assets (eg. Images, Documents, ...) Should be placed inside of an /assets/ folder.

Components should be placed inside of a /components/ folder, and nested inside of eachother when it makes sense (eg. /Person/ inside of /Persons/).

Containing components should be placed inside of a /containers/ folder.

Higher-order components should be placed inside of an /hoc/ folder.

Custom Hooks should be placed in a /hooks/ folder.

Shared functionality (eg. utility.js) should be put in a /shared/ folder.

Anything to do with a global store (eg. Redux) should be placed inside of a /store/ folder.


When finished re-organizing the project structure, we need to ensure every file that imports a component has that path adjusted to match the new location of that file.



------------------------------------
86. Splitting an App Into Components
------------------------------------

We should be splitting up our application as often as we can, to enure every component serves only one purpose. Doing so will keep our application modular, manageable, flexible and scalable. 

We keep as many of these components stateless as possible to ensure we can control the data flow in as few locations as possible.

An example of this would be if you're adding a list of 'Persons' inside of your app, you can create a 'Persons.js' component which would handle the list, 'props' for each item in the list, and passing data on each item back up to the file that controls the state and event handlers (App.js):
--
Persons.js
--
import React from 'react';
import Person from './Person/Person';

const persons = (props) => props.persons.map((person, index) => {
    return <Person 
        click={() => props.clicked(index)}
        name={person.name}
        age={person.age}
        key={person.id}
        changed={(event) => props.changed(event,person.id)}
});

export default persons;
--

--
App.js
--
....

<Persons 
    persons={this.state.persons}
    clicked={this.deletePersonHandler}
    changed={this.nameChangedHandler} />
--

In the example above, 'Persons.js' now handles the mapping for each list item (<Person>), the 'props' for each item, and passing data back up to the stateful component (App.js). 

In 'App.js', <Persons> outputs each <Person> and handles the 'state' and event handlers.



------------------------------------
87. Comparing Stateless and Stateful Components
------------------------------------

When referring to Stateful components (Also called Smart or Container components) it means it's a componnt that manages state. 

Historically, in-order to gain access to the 'state' object inside of a React component it needed to be inside of class based component that 'extends Component'. The 'Component' class gives us access to the 'state' object, and the 'setState()' method.

With React 16+ we can now manage state with react Hooks (shown later in the course), but since all legacy applications will use class based components, below is an example of a Stateful component using the class based approach:
--
class App extends Component {
    state = {
        ....
    }

    ....
        this.setState({ .... });
    ....
}
--

In the example above, the 'state' sets the data and its initial values inside of the application, then later on when we manipulate the state, we use the 'setState()' method.


Stateless components (also called Presentational, Functional or Dumb components) are components that do not manage state.


You should restrict the amount of components in the application that manage state, using as many Stateless components as possible. Doing so helps ensure there is a minimal amount of locations that manage the data of the application. This helps keep your application understandable, manageable, flexible, and scalable. 

Typically an application consists of containers that pull in the components that are relevant to a given section of the application. The containers would be Stateful, and all of the components that are pulled into the container would be Stateless.



------------------------------------
88. Class-based vs Functional Components
------------------------------------

Class-based components:
- class XY extends 'Component
--- Access to State
--- Lifecycle Hooks
--- this.state.XY
--- this.props.XY

Use if you need to manage State or access to Lifecycle Hooks and you don't want to use React Hooks.


Functional components:
- const XY = props => { .... }
--- (React 16+) - Access to State ('useState()' Hook)
--- props.XY

Use in all other cases.


With React 16+, there is now less of a difference between Class-based and Functional components. Both can manage state in their own way, however, Class-based components have access to Lifecycle Hooks, whereas Functional components do not.

If you are working on a project that is below React 16, functional components would not have access to React Hooks, and therefore, could not manage state.

Additionally, Class-based components require you to use the 'this' keyword when accessing 'state' or 'props', whereas Functional components do not.



------------------------------------
89. class Component Lifecycle Overview
------------------------------------





------------------------------------
90. Component Creation Lifecycle in Action
------------------------------------





------------------------------------
91. Component Update Lifecycle (for props Changes)
------------------------------------





------------------------------------
92. Component Update Lifecycle (for state Changes)
------------------------------------





------------------------------------
93. Using useEffect() in Functional Components
------------------------------------





------------------------------------
94. Controlling the useEffect() Behavior
------------------------------------





------------------------------------
95. Cleaning up with Lifecycle Hooks & useEffect()
------------------------------------





------------------------------------
96. Cleanup Work with useEffect() - Ex
------------------------------------





------------------------------------
97. Using shouldComponentUpdate for Optimization
------------------------------------





------------------------------------
98. Optimizing Functional Components with React.memo()
------------------------------------





------------------------------------
99. When should you optimize?
------------------------------------





------------------------------------
100. PureComponents instead of shouldComponentUpdate
------------------------------------





------------------------------------
101. How React Updates the DOM
------------------------------------





------------------------------------
102. Rendering Adjacent JSX Elements
------------------------------------





------------------------------------
103. Windows Users Must Read
------------------------------------





------------------------------------
104. Using React.Fragment
------------------------------------





------------------------------------
105. Higher Order Components (HOC) - Introduction
------------------------------------





------------------------------------
106. Another Form of HOCs
------------------------------------





------------------------------------
107. Passing Unknown Props
------------------------------------





------------------------------------
108. Setting State Correctly
------------------------------------





------------------------------------
109. Using PropTypes
------------------------------------





------------------------------------
110. Using Refs
------------------------------------





------------------------------------
111. Refs with React Hooks
------------------------------------





------------------------------------
112. Understanding Prop Chain Problems
------------------------------------





------------------------------------
113. Using the Context API
------------------------------------





------------------------------------
114. contextType & useContext()
------------------------------------





------------------------------------
115. Wrap Up
------------------------------------





------------------------------------
116. Useful Resources & Links
------------------------------------

