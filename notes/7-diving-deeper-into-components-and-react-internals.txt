==========================================================
Section 7: Diving Deeper into Components & React Internals
==========================================================

------------------------------------
85. A Better Project Structure
------------------------------------

In previous examples we organized components in a sub-optimal way. Ideally we should re-organize our file structure to follow a convention, in-order make it easier to navigate through and find files in our application.

The standard approach would look something like:
--
/src/index.js
/src/App.js
/src/assets/....
/src/components/Persons/Persons.js
/src/components/Persons/Person/Person.js
/src/containers/....
/src/hoc/....
/src/hooks/....
/src/shared/....
/src/store/actions/....
/src/store/reducers/....
/src/store/sagas/....
--

The primary files in the application (App, index, ...) should be in the root of the /src/ folder.

Assets (eg. Images, Documents, ...) Should be placed inside of an /assets/ folder.

Components should be placed inside of a /components/ folder, and nested inside of eachother when it makes sense (eg. /Person/ inside of /Persons/).

Containing components should be placed inside of a /containers/ folder.

Higher-order components should be placed inside of an /hoc/ folder.

Custom Hooks should be placed in a /hooks/ folder.

Shared functionality (eg. utility.js) should be put in a /shared/ folder.

Anything to do with a global store (eg. Redux) should be placed inside of a /store/ folder.


When finished re-organizing the project structure, we need to ensure every file that imports a component has that path adjusted to match the new location of that file.



------------------------------------
86. Splitting an App Into Components
------------------------------------

We should be splitting up our application as often as we can, to enure every component serves only one purpose. Doing so will keep our application modular, manageable, flexible and scalable. We keep as many of these components stateless as possible to ensure we can control the data flow in as few locations as possible.

An example of this would be if you're adding a list of 'Persons' inside of your app, you can create a 'Persons.js' component which would handle the list, 'props' for each item in the list, and passing data on each item back up to the file that controls the state and event handlers (App.js):
--
Persons.js
--
import React from 'react';
import Person from './Person/Person';

const persons = (props) => props.persons.map((person, index) => {
    return <Person 
        click={() => props.clicked(index)}
        name={person.name}
        age={person.age}
        key={person.id}
        changed={(event) => props.changed(event,person.id)}
});

export default persons;
--

--
App.js
--
....

<Persons 
    persons={this.state.persons}
    clicked={this.deletePersonHandler}
    changed={this.nameChangedHandler} />
--

In the example above, 'Persons.js' now handles the mapping for each list item (<Person>), the 'props' for each item, and passing data back up to the stateful component (App.js). 

In 'App.js', <Persons> outputs each <Person> and handles the 'state' and event handlers.



------------------------------------
87. Comparing Stateless and Stateful Components
------------------------------------





------------------------------------
88. Class-based vs Functional Components
------------------------------------





------------------------------------
89. class Component Lifecycle Overview
------------------------------------





------------------------------------
90. Component Creation Lifecycle in Action
------------------------------------





------------------------------------
91. Component Update Lifecycle (for props Changes)
------------------------------------





------------------------------------
92. Component Update Lifecycle (for state Changes)
------------------------------------





------------------------------------
93. Using useEffect() in Functional Components
------------------------------------





------------------------------------
94. Controlling the useEffect() Behavior
------------------------------------





------------------------------------
95. Cleaning up with Lifecycle Hooks & useEffect()
------------------------------------





------------------------------------
96. Cleanup Work with useEffect() - Ex
------------------------------------





------------------------------------
97. Using shouldComponentUpdate for Optimization
------------------------------------





------------------------------------
98. Optimizing Functional Components with React.memo()
------------------------------------





------------------------------------
99. When should you optimize?
------------------------------------





------------------------------------
100. PureComponents instead of shouldComponentUpdate
------------------------------------





------------------------------------
101. How React Updates the DOM
------------------------------------





------------------------------------
102. Rendering Adjacent JSX Elements
------------------------------------





------------------------------------
103. Windows Users Must Read
------------------------------------





------------------------------------
104. Using React.Fragment
------------------------------------





------------------------------------
105. Higher Order Components (HOC) - Introduction
------------------------------------





------------------------------------
106. Another Form of HOCs
------------------------------------





------------------------------------
107. Passing Unknown Props
------------------------------------





------------------------------------
108. Setting State Correctly
------------------------------------





------------------------------------
109. Using PropTypes
------------------------------------





------------------------------------
110. Using Refs
------------------------------------





------------------------------------
111. Refs with React Hooks
------------------------------------





------------------------------------
112. Understanding Prop Chain Problems
------------------------------------





------------------------------------
113. Using the Context API
------------------------------------





------------------------------------
114. contextType & useContext()
------------------------------------





------------------------------------
115. Wrap Up
------------------------------------





------------------------------------
116. Useful Resources & Links
------------------------------------

