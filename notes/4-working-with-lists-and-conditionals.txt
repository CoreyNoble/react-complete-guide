==============================================
Section 4: Working with Lists and Conditionals
==============================================

------------------------------------
53. Rendering Content Conditionally
------------------------------------

Let's say when we click a button, We want to show/hide some content.

Well, first we would set up a unique event handler method to toggle the visibility of the content and would point the <button>'s 'onClick' attribute to the method.

Then we would set up a boolean property in the state, when false, the content will be hidden, and when true, the content will be shown. In our method, we would then swap the polarity of the state property:
( eg. this.setState({propertyName = !propertyName}) ).

Then in our JSX code, we would set up a turnary operator so that when the property in the state is true, we render the JSX, and when the property in the state is false, we render 'null':
( eg. {this.state.propertyName ? <div>....</div> : null} ).

A full example of the above explaination:
--
state = {
    ....,
    showPersons: false
}

togglePersonsHandler = () => {
    const doesShow = this.state.showPersons;
    this.setState({showPersons: !doesShow});
}

render() {
    ...
    return(
        <button onClick={this.togglePersonsHandler}>Toggle People</button>

        { this.state.showPersons ? 
        <div>
            <Person .... />
            <Person .... />
            <Person .... />
        </div> 
        : null
        }
    );
}

--

With this approach, the HTML is not rendered onto the page until the condition is true.



------------------------------------
54. Handling Dynamic Content "The JavaScript Way"
------------------------------------

As our application grows, and as we add more nested conditions, it can be hard to keep track of which expressions are responsible for what. There is a cleaner way to approach this.

Instead of nesting all of this logic inside of the 'return()' statement, we can move this logic above 'return()' instead, (still inside of 'render()'), which keeps the 'return()' statement clean:
--
render() {
    let persons = null;

    if (this.state.showPersons) {
        persons = (
            <div>
                <Person .... />
                <Person .... />
                <Person .... />
            </div>
        );
    }

    return (
        ....
        {persons}
    );
}
--

In the example above, we create 'persons' variable outside of the 'return()' statement. We initially set 'persons' to 'null'. 

We check for the 'showPersons' state in an 'if()' statement. If it is true, then we set 'persons' equal to the JSX we want to render.

With this set up, inside of the 'return()' statement we then reference the 'persons' variable (eg. {persons}). 

Now when the component is rendered, initially 'persons' is 'null', so nothing will be rendered where 'persons' is referenced. The component will be re-rendered as the 'state' changes, and whenever 'showPersons' changes to true, our 'persons' variable will no longer be 'null', and will render our JSX instead.



------------------------------------
56. Outputting Lists
------------------------------------

To dynamically render all of the objects in your state, you can output each item by mapping over each array item in the state object (this.state.property.map()). 

Then when you return inside of the map function, you can output JSX for each item in the array:
--
{this.state.persons.map(person => {
    return <Person
            name={person.name}
            age={person.age} />
})}
--

In the example above, I map over each 'persons' object in the state. For each item (person) I return a <Person /> component with the properties of that object in the state passed into it.
(eg. <Person name={person.name} age={person.age} />).



------------------------------------
57. Lists & State
------------------------------------

If we want to manipulate the state for the given item in a list, we do so by first passing in the index of the array item as we map over the array. 

Then we pass that index into the method we call, and inside of the method, we use that index to manipulate the array item.

--
deletePersonHandler = (personIndex) => {
    const persons = this.state.persons;
    persons.splice(personIndex, 1);
    this.setState({persons: persons});
}

{this.state.persons.map((person, index) => {
    return <Person
            click={() => this.deletePersonHandler(index)}
            name={person.name}
            age={person.age} />
})}
--

In the example above, we '.map()' over 'this.state.persons'. Each item (person) in the array renders a new <Person /> component. We pass in the 'index' of the array item as we '.map()' over the array. 'index' is a property in the array that tracks the current item that is bieng mapped.

Then we pass a 'click' property into the <Person /> component. The 'click' property references our 'deletePersonHandler()' method. We create an arrow function when pointing to our method to ensure the 'this' keyword keeps its context at runtime, and we pass the index into the method.
( eg. click={() => this.deletePersonHandler(index)} )

When the 'click' property is handled inside of the <Person /> component, the 'deletePersonHandler(index)' method is executed. Inside of the method, the 'index' we pass in is deleted from the array using 'splice(index, 1)'. 

'splice(index, 1)' goes to the 'index' in the array, removes that '1' item, then returns the array.

Once the array has been spliced, we then update the state ( this.setState({persons: persons}) ), which deletes the item in the 'state.



------------------------------------
58. Updating State Immutably
------------------------------------





------------------------------------
59. Lists & Keys
------------------------------------





------------------------------------
60. Flexible Lists
------------------------------------





------------------------------------
61. Wrap Up
------------------------------------





------------------------------------
62. Assignment 2 Solution - Lists & Conditionals
------------------------------------





------------------------------------
63. Useful Resources & Links
------------------------------------

